qqnorm(resid(intuitive_mod2))
qqline(resid(intuitive_mod2), col = "red", lwd = 2)
stest = shapiro.test(resid(intuitive_mod2)[1:5000])
par(mfrow = c(1, 2))
plot(fitted(intuitive_mod2), resid(intuitive_mod2), xlab = "Fitted", ylab = "Residuals", main = "Intuitive Model 2 Fit vs. Resid")
plot(fitted(bic_back_mod), resid(bic_back_mod), xlab = "Fitted", ylab = "Residuals", main = "BIC Backward Model Fit vs. Resid")
qqnorm(resid(intuitive_mod2))
qqline(resid(intuitive_mod2), col = "red", lwd = 2)
stest = shapiro.test(resid(intuitive_mod2)[1:5000])
# Given data
data <- data.frame(
Model = c("all_intr_mod", "all_mod", "foreign_sales_mod", "intuitive_mod", "intuitive_mod2", "bic_back_mod"),
R_Squared = c(summary(all_intr_mod)$adj.r.squared,
summary(all_mod)$adj.r.squared,
summary(foreign_sales_mod)$adj.r.squared,
summary(intuitive_mod)$adj.r.squared,
summary(intuitive_mod2)$adj.r.squared,
summary(bic_back_mod)$adj.r.squared),
RMSE = c(sqrt(mean(resid(all_intr_mod) ^ 2)),
sqrt(mean(resid(all_mod) ^ 2)),
sqrt(mean(resid(foreign_sales_mod) ^ 2)),
sqrt(mean(resid(intuitive_mod) ^ 2)),
sqrt(mean(resid(intuitive_mod2) ^ 2)),
sqrt(mean(resid(bic_back_mod) ^ 2)))
)
# Reshape the data to a long format using gather (tidyr)
data_long <- data %>%
gather(metric, value, -Model)
# Install and load required libraries (if not already installed and loaded)
# install.packages("ggplot2")
library(ggplot2)
# Bar plot for R_Squared
ggplot(data_long[data_long$metric == "R_Squared", ], aes(x = Model, y = value)) +
geom_col(fill = "blue") +
labs(x = "Model", y = "R_Squared") +
ggtitle("R_Squared for Different Models") +
theme_minimal()
# Bar plot for RMSE
ggplot(data_long[data_long$metric == "RMSE", ], aes(x = Model, y = value)) +
geom_col(fill = "green") +
labs(x = "Model", y = "RMSE") +
ggtitle("RMSE for Different Models") +
theme_minimal()
# Assuming you have already created the models as shown in your code
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
# Load required packages
library(boot)
# Function to compute the mean squared error for cross-validation
cv_mse <- function(data, model) {
y_actual <- data$NA_Sales
y_predicted <- predict(model, data)
mean((y_actual - y_predicted)^2)
}
# Perform 5-fold cross-validation for each model
cv_results <- lapply(models, function(model) {
cv.glm(data = vgs_modern, glmfit = model, K = 5, cost = cv_mse)
})
# Assuming you have already created the models as shown in your code
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
# Load required packages
library(boot)
# Function to compute the mean squared error for cross-validation
cv_mse <- function(data, model) {
y_actual <- data$NA_Sales
y_predicted <- predict(model, data)
mean((y_actual - y_predicted)^2)
}
# Perform 5-fold cross-validation for each model
cv_results <- lapply(models, function(model) {
cv.glm(data = vgs_modern, glmfit = model, K = 5, predict = cv_mse)
})
# Assuming you have already created the models as shown in your code
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
# Load required packages
library(boot)
# Function to compute the mean squared error for cross-validation
cv_mse <- function(data, model) {
y_actual <- data$NA_Sales
y_predicted <- predict(model, data)
mean((y_actual - y_predicted)^2)
}
# Helper function to perform cross-validation for a given model
perform_cv <- function(model) {
cv.glm(data = vgs_modern, glmfit = model, K = 5, cost = cv_mse)
}
# Perform 5-fold cross-validation for each model
cv_results <- lapply(models, perform_cv)
install.packages("DAAG")
# Assuming you have already created the models as shown in your code
#install.packages("DAAG")
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
# Load required packages
library(DAAG)
# Function to compute the mean squared error for cross-validation
cv_mse <- function(data, model) {
y_actual <- data$NA_Sales
y_predicted <- predict(model, data)
mean((y_actual - y_predicted)^2)
}
# Helper function to perform cross-validation for a given model
perform_cv <- function(model) {
cv.glm(data = vgs_modern, glmfit = model, K = 5, cost = cv_mse)
}
# Perform 5-fold cross-validation for each model
cv_results <- lapply(models, perform_cv)
# Load required packages
library(cvTools)
# Assuming you have already created the models as shown in your code
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
# Function to compute the mean squared error for cross-validation
cv_mse <- function(model, data) {
y_actual <- data$NA_Sales
y_predicted <- predict(model, data)
mean((y_actual - y_predicted)^2)
}
# Helper function to perform cross-validation for a given model
perform_cv <- function(model) {
cvTools::cvfit(vgs_modern, model, cost = cv_mse, K = 5)
}
# Perform 5-fold cross-validation for each model
cv_results <- lapply(models, perform_cv)
# Load required packages
library(cvTools)
# Assuming you have already created the models as shown in your code
models <- list(
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern),
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern),
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern),
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
)
cv_results <- cv.lm(all_intr_mod, k = 5)
cv_results
library(faraway)
library(car)
vgsales = read.csv("vgsales.csv")
# null values per column
na_count = colSums(is.na(vgsales))
# proportion of NA values in each column
na_proportion = na_count / nrow(vgsales) * 100
# table/dataframe for readability
na_records = data.frame(Count = na_count, Proportion = na_proportion)
print(na_records)
# check non-numeric values in Year
unique(vgsales$Year[!grepl("^\\d+$", vgsales$Year)])
# count of "N/A" values in Year column
na_count = sum(vgsales$Year == "N/A")
# proportion of "N/A" values in Year column
na_proportion = na_count / nrow(vgsales) * 100
# print count and proportion
print(paste("Count of 'N/A' in Year: ", na_count))
print(paste("Proportion of 'N/A' in Year (%): ", na_proportion))
# filter the dataset
vgsales = vgsales[vgsales$Year != "N/A",]
# cast datatype
vgsales$Year = as.numeric(vgsales$Year)
str(vgsales)
mean_sales_platform = aggregate(cbind(EU_Sales, JP_Sales, Other_Sales) ~ Platform, vgsales, mean)
print(mean_sales_platform)
# utilizing domain knowledge to filter platforms to only newer ones
new_platforms = c('X360', 'Wii', 'WiiU', 'XOne', 'PS3', 'PS4', 'PSV', '3DS', 'PC')
# Filter data frame to include only specified platforms
vgsales_filtered = vgsales[vgsales$Platform %in% new_platforms, ]
mean_sales_platform_filtered = aggregate(cbind(EU_Sales, JP_Sales, Other_Sales) ~ Platform, vgsales_filtered, mean)
print(mean_sales_platform_filtered)
# Find the platforms with highest mean sales in each region
highest_EU_platform = mean_sales_platform_filtered$Platform[which.max(mean_sales_platform_filtered$EU_Sales)]
highest_JP_platform = mean_sales_platform_filtered$Platform[which.max(mean_sales_platform_filtered$JP_Sales)]
highest_Other_platform = mean_sales_platform_filtered$Platform[which.max(mean_sales_platform_filtered$Other_Sales)]
highest_EU_sales = max(mean_sales_platform_filtered$EU_Sales)
highest_JP_sales = max(mean_sales_platform_filtered$JP_Sales)
highest_Other_sales <- max(mean_sales_platform_filtered$Other_Sales)
cat("Platform with highest mean sales in EU: ", highest_EU_platform, " (", highest_EU_sales, ")", "\n")
cat("Platform with highest mean sales in JP: ", highest_JP_platform, " (", highest_JP_sales, ")", "\n")
cat("Platform with highest mean sales in Other regions: ", highest_Other_platform, "(", highest_Other_sales, ")", "\n")
library(ggplot2)
# Aggregate total sales
eusales_agg = aggregate(EU_Sales ~ Genre, vgsales, sum)
jpsales_agg = aggregate(JP_Sales ~ Genre, vgsales, sum)
othersales_agg = aggregate(Other_Sales ~ Genre, vgsales, sum)
# EU Sales
ggplot(eusales_agg, aes(x = Genre, y = EU_Sales)) +geom_bar(stat = "identity", fill = "lightblue", color = "black") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + labs(x = "Genre", y = "Sales (in millions)", title = "Total EU Sales by Genre")
# JP Sales
ggplot(jpsales_agg, aes(x = Genre, y = JP_Sales)) + geom_bar(stat = "identity", fill = "lightblue", color = "black") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + labs(x = "Genre", y = "Sales (in millions)", title = "Total JP Sales by Genre")
# Other Sales
ggplot(othersales_agg, aes(x = Genre, y = Other_Sales)) + geom_bar(stat = "identity", fill = "lightblue", color = "black") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + labs(x = "Genre", y = "Sales (in millions)", title = "Total Other Sales by Genre")
# convert year (currently chr)
vgsales$Year = as.numeric(vgsales$Year)
# 2010 onward filter
vgsales_current = vgsales[vgsales$Year >= 2010, ]
# Calculate total sales using the filtered data frame
total_sales_year = aggregate(cbind(EU_Sales, JP_Sales, Other_Sales) ~ Year, vgsales_current, sum)
library(ggplot2)
ggplot(total_sales_year, aes(x = as.numeric(Year))) +
geom_line(aes(y = JP_Sales, color = "JP_Sales")) +
geom_line(aes(y = EU_Sales, color = "EU_Sales")) +
geom_line(aes(y = Other_Sales, color = "Other_Sales")) +
labs(color = "Region", x="Year", y = "Total Sales", title = "Yearly Sales by Region")
library(ggplot2)
# year filter
vgsales_current = vgsales[vgsales$Year >= 2010 & vgsales$Year <= 2020, ]
total_sales_platform = aggregate(cbind(EU_Sales, JP_Sales, Other_Sales) ~ Platform, vgsales_current, sum)
ggplot(total_sales_platform, aes(x = Platform, y = JP_Sales)) +
geom_bar(stat="identity") +
theme(axis.text.x = element_text()) +
labs(title = "Total JP Sales by Platform (2010-2020)", x = "Platform", y = "Sales")
ggplot(total_sales_platform, aes(x = Platform, y = EU_Sales)) +
geom_bar(stat="identity") +
theme(axis.text.x = element_text()) +
labs(title = "Total EU Sales by Platform (2010-2020)", x = "Platform", y = "Sales")
ggplot(total_sales_platform, aes(x = Platform, y = Other_Sales)) +
geom_bar(stat="identity") +
theme(axis.text.x = element_text()) +
labs(title = "Total Other Region Sales by Platform (2010-2020)", x = "Platform", y = "Sales")
# Factorize string predictors
vgsales_current$Platform = as.factor(vgsales_current$Platform)
vgsales_current$Genre = as.factor(vgsales_current$Genre)
vgsales_current$Publisher = as.factor(vgsales_current$Publisher)
# Remove unused factor levels
vgsales_modern = droplevels(vgsales_current)
# combine sales predictors into one
Non_NA_Sales = vgsales_modern$EU_Sales + vgsales_modern$JP_Sales + vgsales_modern$Other_Sales
vgs_modern = cbind(vgsales_modern, Non_NA_Sales)
vgs_modern = subset(vgsales_modern, select = -c(EU_Sales, JP_Sales, Other_Sales))
str(vgs_modern)
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern)
all_mod = lm(NA_Sales ~ Platform + Year + Genre + Publisher + Non_NA_Sales, data = vgs_modern)
foreign_sales_mod = lm(NA_Sales ~ Non_NA_Sales, data = vgs_modern)
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern)
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern)
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
par(mfrow = c(1, 2))
plot(fitted(intuitive_mod2), resid(intuitive_mod2), xlab = "Fitted", ylab = "Residuals", main = "Intuitive Model 2 Fit vs. Resid")
plot(fitted(bic_back_mod), resid(bic_back_mod), xlab = "Fitted", ylab = "Residuals", main = "BIC Backward Model Fit vs. Resid")
par(mfrow = c(1, 2))
plot(fitted(intuitive_mod2), resid(intuitive_mod2), xlab = "Fitted", ylab = "Residuals", main = "Intuitive Model 2 Fit vs. Resid")
plot(fitted(bic_back_mod), resid(bic_back_mod), xlab = "Fitted", ylab = "Residuals", main = "BIC Backward Model Fit vs. Resid")
qqnorm(resid(intuitive_mod2))
qqline(resid(intuitive_mod2), col = "red", lwd = 2)
stest = shapiro.test(resid(intuitive_mod2)[1:5000])
# Given data
data <- data.frame(
Model = c("all_intr_mod", "all_mod", "foreign_sales_mod", "intuitive_mod", "intuitive_mod2", "bic_back_mod"),
R_Squared = c(summary(all_intr_mod)$adj.r.squared,
summary(all_mod)$adj.r.squared,
summary(foreign_sales_mod)$adj.r.squared,
summary(intuitive_mod)$adj.r.squared,
summary(intuitive_mod2)$adj.r.squared,
summary(bic_back_mod)$adj.r.squared),
RMSE = c(sqrt(mean(resid(all_intr_mod) ^ 2)),
sqrt(mean(resid(all_mod) ^ 2)),
sqrt(mean(resid(foreign_sales_mod) ^ 2)),
sqrt(mean(resid(intuitive_mod) ^ 2)),
sqrt(mean(resid(intuitive_mod2) ^ 2)),
sqrt(mean(resid(bic_back_mod) ^ 2)))
)
# Reshape the data to a long format using gather (tidyr)
data_long <- data %>%
gather(metric, value, -Model)
# Install and load required libraries (if not already installed and loaded)
# install.packages("ggplot2")
library(ggplot2)
# Bar plot for R_Squared
ggplot(data_long[data_long$metric == "R_Squared", ], aes(x = Model, y = value)) +
geom_col(fill = "blue") +
labs(x = "Model", y = "R_Squared") +
ggtitle("R_Squared for Different Models") +
theme_minimal()
# Bar plot for RMSE
ggplot(data_long[data_long$metric == "RMSE", ], aes(x = Model, y = value)) +
geom_col(fill = "green") +
labs(x = "Model", y = "RMSE") +
ggtitle("RMSE for Different Models") +
theme_minimal()
cv_results <- cv.lm(all_intr_mod, k = 5)
cv.lm(all_intr_mod, k = 5)
library(MASS)
cv_results <- cv.lm(all_intr_mod, k = 5)
library(MASS)
cv_results <- cv.lm(all_intr_mod)
all_intr_mod
summary(all_intr_mod)
library(MASS)
cv.lm(vgs_modern,all_intr_mod, k = 5)
library(caret)
#all_intr_mod = lm(, data = )
#all_mod = lm(NA_Sales ~ Platform + Year + Genre + Publisher + Non_NA_Sales, data = vgs_modern)
#foreign_sales_mod = lm(NA_Sales ~ Non_NA_Sales, data = vgs_modern)
#intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern)
#intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern)
#bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
#specify the cross-validation method
ctrl <- trainControl(method = "cv", number = 5)
model <- train(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern, method = "lm", trControl = ctrl)
vgs_modern.columns
vgs_modern.columns
vgs_modern.column
vgs_modern
str(vgs_modern)
colnames(vgs_modern)
Non_NA_Sales
# combine sales predictors into one
Non_NA_Sales = vgsales_modern$EU_Sales + vgsales_modern$JP_Sales + vgsales_modern$Other_Sales
vgs_modern = cbind(vgsales_modern, Non_NA_Sales)
vgs_modern = subset(vgsales_modern, select = -c(EU_Sales, JP_Sales, Other_Sales))
str(vgs_modern)
library(caret)
#all_intr_mod = lm(, data = )
#all_mod = lm(NA_Sales ~ Platform + Year + Genre + Publisher + Non_NA_Sales, data = vgs_modern)
#foreign_sales_mod = lm(NA_Sales ~ Non_NA_Sales, data = vgs_modern)
#intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern)
#intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern)
#bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
#specify the cross-validation method
ctrl <- trainControl(method = "cv", number = 5)
model <- train(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern, method = "lm", trControl = ctrl)
library(caret)
#all_intr_mod = lm(, data = )
#all_mod = lm(NA_Sales ~ Platform + Year + Genre + Publisher + Non_NA_Sales, data = vgs_modern)
#foreign_sales_mod = lm(NA_Sales ~ Non_NA_Sales, data = vgs_modern)
#intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern)
#intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern)
#bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
#specify the cross-validation method
ctrl <- trainControl(method = "cv", number = 5)
model <- train(NA_Sales ~ Platform * Year * Genre  + Publisher, data = vgs_modern, method = "lm", trControl = ctrl)
#view summary of k-fold CV
print(model)
# Conduct ANOVA tests for each pair of models
anova_results_all_intr_bic_back <- anova(all_intr_mod, bic_back_mod)
anova_results_all_intr_intuitive <- anova(all_intr_mod, intuitive_mod)
anova_results_all_intr_bic_back2 <- anova(all_intr_mod, bic_back_mod2)
# Factorize string predictors
vgsales_current$Platform = as.factor(vgsales_current$Platform)
vgsales_current$Genre = as.factor(vgsales_current$Genre)
vgsales_current$Publisher = as.factor(vgsales_current$Publisher)
# Remove unused factor levels
vgsales_modern = droplevels(vgsales_current)
# combine sales predictors into one
Non_NA_Sales = vgsales_modern$EU_Sales + vgsales_modern$JP_Sales + vgsales_modern$Other_Sales
vgs_modern = cbind(vgsales_modern, Non_NA_Sales)
vgs_modern = subset(vgsales_modern, select = -c(EU_Sales, JP_Sales, Other_Sales))
str(vgs_modern)
all_intr_mod = lm(NA_Sales ~ Platform * Year * Genre * Non_NA_Sales + Publisher, data = vgs_modern)
all_mod = lm(NA_Sales ~ Platform + Year + Genre + Publisher + Non_NA_Sales, data = vgs_modern)
foreign_sales_mod = lm(NA_Sales ~ Non_NA_Sales, data = vgs_modern)
intuitive_mod = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Year, data = vgs_modern)
intuitive_mod2 = lm(NA_Sales ~ Non_NA_Sales * Platform + Non_NA_Sales * Genre + Non_NA_Sales * Publisher + Year, data = vgs_modern)
bic_back_mod = step(all_intr_mod, direction = "backward", trace = FALSE, k = log(nrow(vgs_modern)))
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- aov(all_intr_mod ~ bic_back_mod, data = data)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- aova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- Aova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2)
# Extract ANOVA results
summary(anova1)
summary(anova2)
summary(anova3)
summary(anova4)
summary(anova5)
summary(anova6)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2)
# Extract ANOVA results
print('anova1: ',anova1)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2)
# Extract ANOVA results
print(anova1)
print(anova2)
print(anova3)
print(anova4)
print(anova5)
print(anova6)
anova1 <- anova(all_intr_mod, bic_back_mod,intuitive_mod,intuitive_mod2)
# Extract ANOVA results
print(anova1)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod,intuitive_mod,intuitive_mod2)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2)
# Extract ANOVA results
print(anova1)
print(anova2)
print(anova3)
print(anova4)
print(anova5)
print(anova6)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2)
# Extract ANOVA results
print(anova1)
print(anova2)
print(anova3)
print(anova4)
print(anova5)
print(anova6)
anova1$`Sum of Sq`
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod) #(all intr)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod) # (all_intro)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)  # (all_intro)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod) # (back)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2) # (intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2) # (intuit 2)
# Extract ANOVA results
print(anova1$`Sum of Sq`>0)
print(anova2$`Sum of Sq`>0)
print(anova3$`Sum of Sq`>0)
print(anova4$`Sum of Sq`>0
print(anova5$`Sum of Sq`>0)
# Perform ANOVA between all_intr_mod and bic_back_mod
anova1 <- anova(all_intr_mod, bic_back_mod) #(all intr)
# Perform ANOVA between all_intr_mod and intuitive_mod
anova2 <- anova(all_intr_mod,intuitive_mod) # (all_intro)
# Perform ANOVA between all_intr_mod and intuitive_mod2
anova3 <- anova(all_intr_mod, intuitive_mod2)  # (all_intro)
# Perform ANOVA between bic_back_mod and intuitive_mod
anova4 <- anova(bic_back_mod,intuitive_mod) # (back)
# Perform ANOVA between bic_back_mod and intuitive_mod2
anova5 <- anova(bic_back_mod,intuitive_mod2) # (intuitive_mod2)
# Perform ANOVA between intuitive_mod and intuitive_mod2
anova6 <- anova(intuitive_mod, intuitive_mod2) # (intuit 2)
# Extract ANOVA results
print(anova1$`Sum of Sq`>0)
print(anova2$`Sum of Sq`>0)
print(anova3$`Sum of Sq`>0)
print(anova4$`Sum of Sq`>0)
print(anova5$`Sum of Sq`>0)
print(anova6$`Sum of Sq`>0)
all_intr_mod$xlevels
knitr::opts_chunk$set(echo = TRUE)
